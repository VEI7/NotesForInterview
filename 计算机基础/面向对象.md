# 面向对象

面向对象的三个基本特征是：封装、继承、多态。

- 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。封装可以使得代码模块化。

  优点：

  - 确保用户代码不会无意间破坏封装对象的状态
  - 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码

- 继承性：让某种类型对象获得另一个类型对象的属性和方法。继承可以扩展已存在的代码

- 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。多态的目的则是为了接口重用

#### 继承

public：公共的，任何地方都可以访问（struct默认）

protected：子类内部、当前类内部可以访问

private：私有的，只有当前类内部可以访问（class默认）

子类内部访问父类成员的权限，是以下2项中权限最小的那个：
1.成员本身的访问权限
2.上一级父类的继承方式

#####为什么需要继承？什么时候应该继承？

使用继承可以有效实现代码复用，避免重复代码的出现。

当两个类具有相同的特征（属性）和行为（方法）时，可以将相同的部分抽取出来放到一个类中作为父类，其它两个类继承这个父类。

#### 多态

同一个实现接口，使用不同的实例而执行不同的操作。

多态可分为静态多态和动态多态。

##### 静态多态

指在编译期间就可以确定函数的调用地址，并生产代码， 静态多态往往通过**函数重载**（运算符重载）和**模版（泛型编程）**来实现。重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）

##### 动态多态

 C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。当使用**基类的引用或指针调用虚成员函数**时会执行动态绑定。动态绑定直到运行的时候才知道到底调用哪个版本的虚函数，所以必为每一个虚函数都提供定义，而不管它是否被用到，这是因为连编译器都无法确定到底会使用哪个虚函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。

##### 如何实现多态？

一般做法是：写一个方法，它只接收父类作为参数，编写的代码只与父类打交道。调用这个方法时，实例化不同的子类对象（new 一个对象）。

更具体的说：

（1）、子类重写父类的方法。使子类具有不同的方法实现。

（2）、把父类类型作为参数类型，该父类及其子类对象作为参数转入。

（3）、运行时，根据实际创建的对象类型动态决定使用那个方法。



对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。 在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了 这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

```c++
class Base
{
    public:
    virtual void f(){cout<<"Base::f"<<endl;}
    virtual void g(){cout<<"Base::g"<<endl;}
    virtual void h(){cout<<"Base::h"<<endl;}
};
class Derived:public Base
{
	public:
    virtual void f(){cout<<"Derived::f"<<endl;}
    virtual void g1(){cout<<"Derived::g1"<<endl;}
    virtual void h1(){cout<<"Derived::h1"<<endl;}
};

```



#### 纯虚函数

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:

```c++
virtual void funtion1()=0
```

**二、引入原因**

1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。

2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。

声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。

**纯虚函数最显著的特征是**：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。

定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。

纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的默认实现。所以类纯虚函数的声明就是在告诉子类的设计者，"你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它"。



#### 什么情况下析构函数需要定义为虚函数

只有当一个类被用来作为基类的时候,并且有使用到基类指针操作派生类的情况时，才把析构函数写成虚函数。基类指针可以指向派生类的对象（多态性），如果删除该指针delete []p；就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。